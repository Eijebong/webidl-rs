use lexer::*;

grammar;

// placeholder
pub Num: i32 = {
    "void" => 0
};

extern {
    type Error = LexicalError;
    type Location = usize;

    enum Token {
        // Keywords
        "any" => Token::Any,
        "ArrayBuffer" => Token::ArrayBuffer,
        "attribute" => Token::Attribute,
        "boolean" => Token::Boolean,
        "byte" => Token::Byte,
        "ByteString" => Token::ByteString,
        "callback" => Token::Callback,
        "const" => Token::Const,
        "DataView" => Token::DataView,
        "deleter" => Token::Deleter,
        "dictionary" => Token::Dictionary,
        "DOMException" => Token::DOMException,
        "DOMString" => Token::DOMString,
        "double" => Token::Double,
        "enum" => Token::Enum,
        "Error" => Token::Error,
        "false" => Token::False,
        "float" => Token::Float,
        "Float32Array" => Token::Float32Array,
        "Float64Array" => Token::Float64Array,
        "FrozenArray" => Token::FrozenArray,
        "getter" => Token::Getter,
        "implements" => Token::Implements,
        "inherit" => Token::Inherit,
        "Int16Array" => Token::Int16Array,
        "Int32Array" => Token::Int32Array,
        "Int8Array" => Token::Int8Array,
        "interface" => Token::Interface,
        "iterable" => Token::Iterable,
        "legacycaller" => Token::LegacyCaller,
        "long" => Token::Long,
        "maplike" => Token::Maplike,
        "namespace" => Token::Namespace,
        "NaN" => Token::NaN,
        "-Infinity" => Token::NegativeInfinity,
        "null" => Token::Null,
        "object" => Token::Object,
        "octet" => Token::Octet,
        "optional" => Token::Optional,
        "or" => Token::Or,
        "partial" => Token::Partial,
        "Infinity" => Token::PositiveInfinity,
        "Promise" => Token::Promise,
        "readonly" => Token::ReadOnly,
        "record" => Token::Record,
        "required" => Token::Required,
        "sequence" => Token::Sequence,
        "serializer" => Token::Serializer,
        "setlike" => Token::Setlike,
        "setter" => Token::Setter,
        "short" => Token::Short,
        "static" => Token::Static,
        "stringifier" => Token::Stringifier,
        "true" => Token::True,
        "typedef" => Token::Typedef,
        "USVString" => Token::USVString,
        "Uint16Array" => Token::Uint16Array,
        "Uint32Array" => Token::Uint32Array,
        "Uint8Array" => Token::Uint8Array,
        "Uint8ClampedArray" => Token::Uint8ClampedArray,
        "unrestricted" => Token::Unrestricted,
        "unsigned" => Token::Unsigned,
        "void" => Token::Void,

        // Regular expressions
        "FloatLiteral" => Token::FloatLiteral(<f64>),
        "Identifier" => Token::Identifier(<String>),
        "IntegerLiteral" => Token::IntegerLiteral(<i64>),
        "OtherLiteral" => Token::OtherLiteral(<char>),
        "StringLiteral" => Token::StringLiteral(<String>),

        // Symbols
        ":" => Token::Colon,
        "," => Token::Comma,
        "..." => Token::Ellipsis,
        "=" => Token::Equals,
        ">" => Token::GreaterThan,
        "-" => Token::Hyphen,
        "{" => Token::LeftBrace,
        "[" => Token::LeftBracket,
        "(" => Token::LeftParenthesis,
        "<" => Token::LessThan,
        "." => Token::Period,
        "?" => Token::QuestionMark,
        "}" => Token::RightBrace,
        "]" => Token::RightBracket,
        ")" => Token::RightParenthesis,
        ";" => Token::Semicolon,
    }
}
